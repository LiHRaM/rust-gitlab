// Copyright 2016 Kitware, Inc.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

extern crate chrono;
use self::chrono::{DateTime, NaiveDate, TimeZone, UTC};

extern crate serde;
use self::serde::{Deserialize, Deserializer, Serialize, Serializer};
use self::serde::de::{Error, Type};

extern crate serde_json;
use self::serde_json::Value;

use super::types::{BuildId, IssueId, IssueState, MergeRequestId, MergeRequestState, MergeStatus,
                   MilestoneId, NoteId, NoteType, NoteableId, ObjectId, ProjectId, SnippetId,
                   UserId};

#[derive(Debug, Clone, Copy)]
pub struct HookDate(DateTime<UTC>);

impl Serialize for HookDate {
    fn serialize<S: Serializer>(&self, serializer: &mut S) -> Result<(), S::Error> {
        self.0.serialize(serializer)
    }
}

impl Deserialize for HookDate {
    fn deserialize<D: Deserializer>(deserializer: &mut D) -> Result<Self, D::Error> {
        let val = try!(String::deserialize(deserializer));

        UTC.datetime_from_str(&val, "%Y-%m-%d %H:%M:%S UTC")
            .or_else(|_| {
                DateTime::parse_from_str(&val, "%Y-%m-%d %H:%M:%S %z")
                    .map_err(|err| D::Error::invalid_value(&format!("{:?}", err)))
                    .map(|dt| dt.with_timezone(&UTC))
            })
            .map(HookDate)
    }
}

impl AsRef<DateTime<UTC>> for HookDate {
    fn as_ref(&self) -> &DateTime<UTC> {
        &self.0
    }
}

#[derive(Serialize, Deserialize, Debug)]
/// Project information exposed in hooks.
pub struct ProjectHookAttrs {
    /// The display name of the project.
    pub name: String,
    /// The description of the project.
    pub description: Option<String>,
    /// The URL for the project's homepage.
    pub web_url: String,
    /// The URL to the project avatar.
    pub avatar_url: Option<String>,
    /// The URL to clone the repository over SSH.
    pub git_ssh_url: String,
    /// The URL to clone the repository over HTTPS.
    pub git_http_url: String,
    /// The namespace the project lives in.
    pub namespace: String,
    /// Integral value for the project's visibility.
    pub visibility_level: u64,
    /// The path to the project's repository with its namespace.
    pub path_with_namespace: String,
    /// The default branch for the project.
    pub default_branch: String,
}

#[derive(Serialize, Deserialize, Debug)]
/// Wiki project information exposed in hooks.
pub struct ProjectWikiHookAttrs {
    /// The URL for the project's homepage.
    pub web_url: String,
    /// The URL to clone the repository over SSH.
    pub git_ssh_url: String,
    /// The URL to clone the repository over HTTPS.
    pub git_http_url: String,
    /// The path to the project's repository with its namespace.
    pub path_with_namespace: String,
    /// The default branch for the project.
    pub default_branch: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct UserHookAttrs {
    pub name: String,
    pub username: String,
    pub avatar_url: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct HookCommitIdentity {
    pub name: String,
    pub email: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct CommitHookAttrs {
    pub id: ObjectId,
    pub message: String,
    pub timestamp: DateTime<UTC>,
    pub url: String,
    pub author: HookCommitIdentity,
    pub added: Option<Vec<String>>,
    pub modified: Option<Vec<String>>,
    pub removed: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct PushHook {
    pub object_kind: String,
    pub before: ObjectId,
    pub after: ObjectId,
    #[serde(rename="ref")]
    pub ref_: String,
    pub checkout_sha: Option<ObjectId>,
    pub message: Option<String>,
    pub user_id: UserId,
    pub user_name: String,
    pub user_email: String,
    pub user_avatar: String,
    pub project_id: ProjectId,
    pub project: ProjectHookAttrs,
    pub commits: Vec<CommitHookAttrs>, // limited to 20 commits
    pub total_commits_count: u64,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum IssueAction {
    Update,
    Open,
    Close,
    Reopen,
}
enum_serialize!(IssueAction -> "issue action",
    Update => "update",
    Open => "open",
    Close => "close",
    Reopen => "reopen",
);

#[derive(Serialize, Deserialize, Debug)]
pub struct IssueHookAttrs {
    pub id: IssueId,
    pub title: String,
    pub assignee_id: Option<UserId>,
    pub author_id: UserId,
    pub project_id: ProjectId,
    pub created_at: HookDate,
    pub updated_at: HookDate,
    pub deleted_at: Option<HookDate>,
    pub due_date: Option<NaiveDate>,
    pub updated_by_id: Option<UserId>,
    pub moved_to_id: Option<Value>, // ???
    pub position: u64,
    pub branch_name: Option<String>,
    pub description: String,
    pub milestone_id: Option<MilestoneId>,
    pub state: IssueState,
    pub iid: u64,
    pub confidential: bool,
    pub lock_version: u64,

    // It seems that notes miss these properties?
    pub url: Option<String>,
    pub action: Option<IssueAction>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct IssueHook {
    pub object_kind: String,
    pub user: UserHookAttrs,
    pub project: ProjectHookAttrs,
    pub object_attributes: IssueHookAttrs,
    pub assignee: Option<UserHookAttrs>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MergeRequestAction {
    Update,
    Open,
    Close,
    Reopen,
    Merge,
}
enum_serialize!(MergeRequestAction -> "merge request action",
    Update => "update",
    Open => "open",
    Close => "close",
    Reopen => "reopen",
    Merge => "merge",
);

#[derive(Serialize, Deserialize, Debug)]
pub struct MergeRequestParams {
    force_remove_source_branch: Option<Value>, // sigh
}

impl MergeRequestParams {
    // https://gitlab.com/gitlab-org/gitlab-ce/issues/20880
    pub fn force_remove_source_branch(&self) -> bool {
        self.force_remove_source_branch
            .as_ref()
            .map(|val| {
                if let Some(as_str) = val.as_str() {
                    as_str == "1"
                } else if let Some(as_bool) = val.as_bool() {
                    as_bool
                } else {
                    error!(target: "gitlab",
                           "unknown value for force_remove_source_branch: {}", val);
                    false
                }
            })
            .unwrap_or(false)
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub struct MergeRequestHookAttrs {
    pub source: ProjectHookAttrs,
    pub target: ProjectHookAttrs,
    pub last_commit: Option<CommitHookAttrs>,
    pub work_in_progress: bool,
    pub in_progress_merge_commit_sha: Option<ObjectId>,

    pub id: MergeRequestId,
    pub target_branch: String,
    pub target_project_id: ProjectId,
    pub source_branch: String,
    pub source_project_id: ProjectId,
    pub author_id: UserId,
    pub assignee_id: Option<UserId>,
    pub title: String,
    pub created_at: HookDate,
    pub updated_at: HookDate,
    pub deleted_at: Option<HookDate>,
    pub locked_at: Option<HookDate>,
    pub updated_by_id: Option<UserId>,
    pub merge_commit_sha: Option<ObjectId>,
    pub merge_error: Option<Value>, // String?
    pub merge_params: MergeRequestParams,
    pub merge_user_id: Option<UserId>,
    pub merge_when_build_succeeds: bool,
    pub position: u64, // ???
    // st_commits
    // st_diffs
    pub milestone_id: Option<MilestoneId>,
    pub oldrev: Option<ObjectId>,
    pub state: MergeRequestState,
    pub merge_status: MergeStatus,
    pub iid: u64,
    pub description: Option<String>,
    pub lock_version: u64,

    // It seems that notes miss these properties?
    pub url: Option<String>,
    pub action: Option<MergeRequestAction>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct MergeRequestHook {
    pub object_kind: String,
    pub user: UserHookAttrs,
    pub project: ProjectHookAttrs,
    pub object_attributes: MergeRequestHookAttrs,
    pub assignee: Option<UserHookAttrs>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SnippetType {
    Project,
    Personal,
}
enum_serialize!(SnippetType -> "snippet type",
    Project => "ProjectSnippet",
    Personal => "PersonalSnippet",
);

#[derive(Serialize, Deserialize, Debug)]
pub struct SnippetHookAttrs {
    pub title: String,
    pub content: String,
    pub author_id: UserId,
    pub project_id: Option<ProjectId>,
    pub created_at: HookDate,
    pub updated_at: HookDate,
    pub file_name: String,
    #[serde(rename="type")]
    pub type_: SnippetType,
    pub visibility_level: u64,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum WikiPageAction {
    Create,
    Update,
}
enum_serialize!(WikiPageAction -> "wiki page action",
    Create => "create",
    Update => "update",
);

#[derive(Serialize, Deserialize, Debug)]
pub struct WikiPageHookAttrs {
    pub title: String,
    pub content: String,
    pub format: String,
    pub message: String,
    pub slug: String,

    pub url: String,
    pub action: WikiPageAction,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct DiffHookAttrs {
    pub diff: String,
    pub new_path: String,
    pub old_path: String,
    pub a_mode: String, // TODO: Create a mode type.
    pub b_mode: String, // TODO: Create a mode type.
    pub new_file: bool,
    pub renamed_file: bool,
    pub deleted_file: bool,
    pub too_large: bool,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(deny_unknown_fields)]
// FIXME: This can apparently be a string sometimes.
// https://gitlab.com/gitlab-org/gitlab-ce/issues/21467
pub struct PositionHookAttrs {
    pub base_sha: ObjectId,
    pub head_sha: ObjectId,
    pub start_sha: ObjectId,
    pub old_line: Option<u64>,
    pub old_path: String,
    pub new_line: Option<u64>,
    pub new_path: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct NoteHookAttrs {
    pub id: NoteId,
    pub note: String,
    pub noteable_type: NoteType,
    pub original_position: Option<PositionHookAttrs>,
    pub position: Option<PositionHookAttrs>,
    pub author_id: UserId,
    pub created_at: HookDate,
    pub updated_at: HookDate,
    pub updated_by_id: Option<UserId>,
    pub resolved_at: Option<HookDate>,
    pub resolved_by_id: Option<UserId>,
    pub project_id: ProjectId,
    pub attachment: Option<String>,
    pub line_code: Option<String>, // TODO: This is some internal format.
    pub commit_id: Option<ObjectId>, // XXX(8.11): apparently can be an empty string?
    pub discussion_id: ObjectId,
    pub original_discussion_id: Option<ObjectId>,
    noteable_id: Value, // Keep as JSON because its type depends on what `noteable_type` is.
    pub system: bool,
    pub st_diff: Option<DiffHookAttrs>,
    pub url: String,

    #[serde(rename="type")]
    pub type_: Option<String>, // ???
    //pub is_award: bool, // seems to have been removed?
}

impl NoteHookAttrs {
    /// The ID of the object the note is for.
    pub fn noteable_id(&self) -> Option<NoteableId> {
        match self.noteable_type {
            NoteType::Commit => {
                self.noteable_id
                    .as_str()
                    .map(|id| NoteableId::Commit(ObjectId::new(id)))
            },
            NoteType::Issue => {
                self.noteable_id
                    .as_u64()
                    .map(|id| NoteableId::Issue(IssueId::new(id)))
            },
            NoteType::MergeRequest => {
                self.noteable_id
                    .as_u64()
                    .map(|id| NoteableId::MergeRequest(MergeRequestId::new(id)))
            },
            NoteType::Snippet => {
                self.noteable_id
                    .as_u64()
                    .map(|id| NoteableId::Snippet(SnippetId::new(id)))
            },
        }
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub struct NoteHook {
    pub object_kind: String,
    pub user: UserHookAttrs,
    pub project_id: ProjectId,
    pub project: ProjectHookAttrs,
    pub object_attributes: NoteHookAttrs,
    pub commit: Option<CommitHookAttrs>,
    pub issue: Option<IssueHookAttrs>,
    pub merge_request: Option<MergeRequestHookAttrs>,
    pub snippet: Option<SnippetHookAttrs>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct BuildUserHookAttrs {
    pub id: Option<UserId>,
    pub name: Option<String>,
    pub email: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct BuildCommitHookAttrs {
    pub id: String,
    pub sha: String,
    pub message: String,
    pub author_name: String,
    pub author_email: String,
    pub status: String,
    pub duration: u64,
    pub started_at: Option<HookDate>,
    pub finished_at: Option<HookDate>,
}

#[derive(Serialize, Deserialize, Debug)]
/// Project information exposed in build hooks.
pub struct BuildProjectHookAttrs {
    /// The display name of the project.
    pub name: String,
    /// The description of the project.
    pub description: Option<String>,
    /// The URL for the project's homepage.
    pub homepage: String,
    /// The URL to clone the repository over HTTPS.
    pub git_http_url: String,
    /// The URL to clone the repository over SSH.
    pub git_ssh_url: String,
    /// Integral value for the project's visibility.
    pub visibility_level: u64,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct BuildHook {
    pub object_kind: String,
    #[serde(rename="ref")]
    pub ref_: String,
    pub tag: String,
    pub before_sha: String,
    pub sha: String,
    pub build_id: BuildId,
    pub build_name: String,
    pub build_stage: String,
    pub build_started_at: Option<HookDate>,
    pub build_finished_at: Option<HookDate>,
    pub build_duration: Option<u64>,
    pub build_allow_failure: bool,
    pub project_id: ProjectId,
    pub user: BuildUserHookAttrs,
    pub commit: BuildCommitHookAttrs,
    pub repository: BuildProjectHookAttrs,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct WikiPageHook {
    pub object_kind: String,
    pub user: UserHookAttrs,
    pub project: ProjectHookAttrs,
    pub wiki: ProjectWikiHookAttrs,
    pub object_attributes: WikiPageHookAttrs,
}

#[derive(Debug)]
pub enum WebHook {
    Push(PushHook),
    Issue(IssueHook),
    MergeRequest(MergeRequestHook),
    Note(NoteHook),
    Build(BuildHook),
    WikiPage(WikiPageHook),
}

impl Deserialize for WebHook {
    fn deserialize<D: Deserializer>(deserializer: &mut D) -> Result<Self, D::Error> {
        let val = try!(Value::deserialize(deserializer));

        let object_kind = match val.pointer("/object_kind") {
                Some(&Value::String(ref kind)) => kind,
                Some(_) => {
                    return Err(D::Error::invalid_type(Type::String));
                },
                None => {
                    return Err(D::Error::missing_field("object_kind"));
                },
            }
            .to_string();

        let hook_res = match object_kind.as_str() {
            "push" | "tag_push" => serde_json::from_value(val).map(WebHook::Push),

            "issue" => serde_json::from_value(val).map(WebHook::Issue),

            "merge_request" => serde_json::from_value(val).map(WebHook::MergeRequest),

            "note" => serde_json::from_value(val).map(WebHook::Note),

            "build" => serde_json::from_value(val).map(WebHook::Build),

            _ => {
                return Err(D::Error::invalid_value(&format!("unrecognized webhook object kind: {}",
                                                            object_kind)));
            },
        };

        hook_res.map_err(|err| D::Error::invalid_value(&format!("{:?}", err)))
    }
}
