// Copyright 2016 Kitware, Inc.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

extern crate chrono;
use self::chrono::{DateTime, NaiveDate, UTC};

extern crate serde;
use self::serde::{Deserialize, Deserializer, Serialize, Serializer};
use self::serde::de::Error;

extern crate serde_json;
use self::serde_json::Value;

use std::fmt::{self, Display, Formatter};

// This is only used in internal API calls.
//#[derive(Serialize, Deserialize, Debug)]
//pub struct UserSafe {
//    pub username: String,
//    pub name: String,
//}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
/// Type-safe user ID.
pub struct UserId(u64);
impl_id!(UserId);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
/// The states a user account can be in.
pub enum UserState {
    /// The user is active and may perform actions.
    Active,
    /// Blocked from logging in.
    Blocked,
    /// Blocked from logging in via LDAP.
    LdapBlocked,
}
enum_serialize!(UserState -> "user state",
    Active => "active",
    Blocked => "blocked",
    LdapBlocked => "ldap_blocked",
);

#[derive(Serialize, Deserialize, Debug)]
/// Basic user information.
pub struct UserBasic {
    /// The username.
    pub username: String,
    /// The display name.
    pub name: String,
    /// The user's ID.
    pub id: UserId,
    /// The state of the user account.
    pub state: UserState,
    /// The URL of the user's avatar.
    pub avatar_url: String,
    /// The URL of the user's profile page.
    pub web_url: String,
}

pub trait UserResult: Serialize + Deserialize {}
impl<T: Serialize + Deserialize + Into<UserBasic>> UserResult for T {}

#[derive(Serialize, Deserialize, Debug)]
/// More detailed information only accessible to administrators.
pub struct User {
    /// The username.
    pub username: String,
    /// The display name.
    pub name: String,
    /// The user's ID.
    pub id: UserId,
    /// The state of the user account.
    pub state: UserState,
    /// The URL of the user's avatar.
    pub avatar_url: String,
    /// The URL of the user's profile page.
    pub web_url: String,
    /// When the account was created.
    pub created_at: DateTime<UTC>,
    /// Whether the user is an administrator or not.
    pub is_admin: bool,
    /// Self-described biography of the user.
    pub bio: Option<String>,
    /// Geographic location of the user.
    pub location: Option<String>,

    /// Skype contact information.
    pub skype: String,
    /// LinkedIn contact information.
    pub linkedin: String,
    /// Twitter contact information.
    pub twitter: String,
    /// Custom URL for the user's website.
    pub website_url: String,
}

impl From<User> for UserBasic {
    fn from(user: User) -> Self {
        UserBasic {
            username: user.username,
            name: user.name,
            id: user.id,
            state: user.state,
            avatar_url: user.avatar_url,
            web_url: user.web_url,
        }
    }
}

#[derive(Serialize, Deserialize, Debug)]
/// External authentication tokens.
pub struct Identity {
    /// The provider of the token.
    pub provider: String,
    /// The UID for the provider.
    pub extern_uid: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
/// Type-safe theme ID.
pub struct ThemeId(u64);

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
/// Type-safe color scheme ID.
pub struct ColorSchemeId(u64);

#[derive(Serialize, Deserialize, Debug)]
/// Full user structure information.
pub struct UserFull {
    /// The username.
    pub username: String,
    /// The display name.
    pub name: String,
    /// The user's ID.
    pub id: UserId,
    /// The state of the user account.
    pub state: UserState,
    /// The URL of the user's avatar.
    pub avatar_url: String,
    /// The URL of the user's profile page.
    pub web_url: String,
    /// When the account was created.
    pub created_at: DateTime<UTC>,
    /// Whether the user is an administrator or not.
    pub is_admin: bool,
    /// Self-described biography of the user.
    pub bio: Option<String>,
    /// Geographic location of the user.
    pub location: Option<String>,

    /// Skype contact information.
    pub skype: String,
    /// LinkedIn contact information.
    pub linkedin: String,
    /// Twitter contact information.
    pub twitter: String,
    /// Custom URL for the user's website.
    pub website_url: String,

    /// When the user last logged in.
    pub last_sign_in_at: Option<DateTime<UTC>>,
    /// When the user's account was confirmed.
    pub confirmed_at: DateTime<UTC>,
    /// The primary email address for the user.
    pub email: String,

    /// The theme used by the user.
    pub theme_id: ThemeId,
    /// The color scheme used by the user.
    pub color_scheme_id: ColorSchemeId,
    /// The number of projects the user may create.
    pub projects_limit: u64,
    /// When the user's current session started.
    pub current_sign_in_at: Option<DateTime<UTC>>,

    /// List of identities associated with the user.
    pub identities: Vec<Identity>,

    /// Whether the user can create groups.
    pub can_create_group: bool,
    /// Whether the user can create a new project.
    pub can_create_project: bool,
    /// Whether the user has two-factor authentication enabled.
    pub two_factor_enabled: bool,
    /// Whether the account is externally controlled.
    pub external: bool,

    // There's a `UserLogin` structure as well which contains this key too, but the API already has
    // this token, so this is being skipped.
    //pub private_token: String,
}

impl From<UserFull> for UserBasic {
    fn from(user: UserFull) -> Self {
        UserBasic {
            username: user.username,
            name: user.name,
            id: user.id,
            state: user.state,
            avatar_url: user.avatar_url,
            web_url: user.web_url,
        }
    }
}

impl From<UserFull> for User {
    fn from(user: UserFull) -> Self {
        User {
            username: user.username,
            name: user.name,
            id: user.id,
            state: user.state,
            avatar_url: user.avatar_url,
            web_url: user.web_url,
            created_at: user.created_at,
            is_admin: user.is_admin,
            bio: user.bio,
            location: user.location,
            skype: user.skype,
            linkedin: user.linkedin,
            twitter: user.twitter,
            website_url: user.website_url,
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub struct EmailId(u64);
impl_id!(EmailId);

#[derive(Serialize, Deserialize, Debug)]
/// Email address.
pub struct Email {
    /// ID of the email.
    pub id: EmailId,
    /// The email address.
    pub email: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub struct HookId(u64);
impl_id!(HookId);

#[derive(Serialize, Deserialize, Debug)]
/// A web hook to notify of events.
pub struct Hook {
    /// The ID of the hook.
    pub id: HookId,
    /// The URL to contact.
    pub url: String,
    /// When the hook was created.
    pub created_at: DateTime<UTC>,
}

#[derive(Serialize, Deserialize, Debug)]
/// A web hook to notify of project events.
pub struct ProjectHook {
    /// The ID of the hook.
    pub id: HookId,
    /// The URL to contact.
    pub url: String,
    /// When the hook was created.
    pub created_at: DateTime<UTC>,
    /// The project associated with the hook.
    pub project_id: ProjectId,
    /// Whether the hook is contacted for push events.
    pub push_events: bool,
    /// Whether the hook is contacted for issue events.
    pub issues_events: bool,
    /// Whether the hook is contacted for merge request events.
    pub merge_requests_events: bool,
    /// Whether the hook is contacted for note events.
    pub note_events: bool,
    /// Whether the communication with the hook is verified using TLS certificates.
    pub enable_ssl_verification: bool,
    /// Whether the hook is contacted for build events.
    pub build_events: bool,
    /// Whether the hook is contacted for pipeline events.
    pub pipeline_events: bool,
    /// Whether the hook is contacted for wiki page events.
    pub wiki_page_events: bool,
}

impl From<ProjectHook> for Hook {
    fn from(hook: ProjectHook) -> Self {
        Hook {
            id: hook.id,
            url: hook.url,
            created_at: hook.created_at,
        }
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct WebhookEvents {
    build: bool,
    issues: bool,
    merge_requests: bool,
    note: bool,
    pipeline: bool,
    push: bool,
    wiki_page: bool,
}

impl WebhookEvents {
    pub fn new() -> Self {
        WebhookEvents {
            build: false,
            issues: false,
            merge_requests: false,
            note: false,
            pipeline: false,
            push: false,
            wiki_page: false,
        }
    }

    with_event!{with_build, build}
    with_event!{with_issues, issues}
    with_event!{with_merge_requests, merge_requests}
    with_event!{with_note, note}
    with_event!{with_pipeline, pipeline}
    with_event!{with_push, push}
    with_event!{with_wiki_page, wiki_page}

    get_event!{build}
    get_event!{issues}
    get_event!{merge_requests}
    get_event!{note}
    get_event!{pipeline}
    get_event!{push}
    get_event!{wiki_page}
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
/// Type-safe project ID.
pub struct ProjectId(u64);
impl_id!(ProjectId);

#[derive(Serialize, Deserialize, Debug)]
/// Basic project information.
pub struct BasicProjectDetails {
    /// The ID of the project.
    pub id: ProjectId,
    /// The display name of the project.
    pub name: String,
    /// The display name of the project with the namespace.
    pub name_with_namespace: String,
    /// The path to the project's repository.
    pub path: String,
    /// The path to the project's repository with its namespace.
    pub path_with_namespace: String,
    pub http_url_to_repo: String,
    pub web_url: String,
}

/// Visibility levels of projects.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum VisibilityLevel {
    Public = 20,
    Internal = 10,
    Private = 0,
}

impl From<VisibilityLevel> for u64 {
    fn from(visibility: VisibilityLevel) -> Self {
        match visibility {
            VisibilityLevel::Public => 20,
            VisibilityLevel::Internal => 10,
            VisibilityLevel::Private => 0,
        }
    }
}

impl Display for VisibilityLevel {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(f, "{}", Into::<u64>::into(self.clone()))
    }
}

// TODO: enum for NotificationLevel

#[derive(Serialize, Deserialize, Debug)]
pub struct SharedGroup {
    pub group_id: GroupId,
    pub group_name: String,
    pub group_access_level: u64,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
// Called `MemberAccess` in entities.rb, but it is just a base class for `ProjectAccess` and
// `GroupAccess`. Combine them here.
pub struct MemberAccess {
    pub access_level: u64,
    pub notification_level: Option<u64>,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
pub struct Permissions {
    pub project_access: Option<MemberAccess>,
    pub group_access: Option<MemberAccess>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct ProjectNamespaceAvatar {
    pub url: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct ProjectNamespace {
    pub name: String,
    pub path: String,
    pub description: String,
    pub id: u64,
    owner_id: Option<u64>,
    pub created_at: DateTime<UTC>,
    pub updated_at: DateTime<UTC>,
    pub deleted_at: Option<DateTime<UTC>>,
    pub visibility_level: u64,
    pub avatar: Option<ProjectNamespaceAvatar>,
    pub lfs_enabled: Option<bool>,
    pub request_access_enabled: bool,
    pub share_with_group_lock: bool,
}

impl ProjectNamespace {
    pub fn owner_id(&self) -> NamespaceId {
        match self.owner_id {
            Some(_) => NamespaceId::User(UserId(self.id)),
            None => NamespaceId::Group(GroupId(self.id)),
        }
    }
}

#[derive(Serialize, Deserialize, Debug)]
/// Project information.
pub struct Project {
    /// The ID of the project.
    pub id: ProjectId,
    /// The description of the project.
    pub description: Option<String>,
    /// The default branch for the project.
    pub default_branch: Option<String>,
    /// A list of tags for the project.
    pub tag_list: Vec<String>,
    /// Whether the project is publicly visible or not.
    pub public: bool,
    /// Whether the project is archived or not.
    pub archived: bool,
    /// Integral value for the project's visibility.
    pub visibility_level: u64,
    /// The URL to clone the repository over SSH.
    pub ssh_url_to_repo: String,
    /// The URL to clone the repository over HTTPS.
    pub http_url_to_repo: String,
    /// The URL for the project's homepage.
    pub web_url: String,
    /// The owner of the project (`None` for a group-owned project).
    pub owner: Option<UserBasic>,
    /// The display name of the project.
    pub name: String,
    /// The display name of the project with the namespace.
    pub name_with_namespace: String,
    /// The path to the project's repository.
    pub path: String,
    /// The path to the project's repository with its namespace.
    pub path_with_namespace: String,
    /// Whether the continuous integration container registry is enabled.
    ///
    /// This is supposed to be just `bool`, but projects created before the registry was
    /// supported appear to return `null`.
    pub container_registry_enabled: Option<bool>,
    /// When the repository was created.
    pub created_at: DateTime<UTC>,
    /// When the last activity on the project occurred.
    pub last_activity_at: DateTime<UTC>,
    /// Whether continuous integration shared runners are enabled.
    pub shared_runners_enabled: bool,
    /// Whether LFS object storage is enabled.
    pub lfs_enabled: bool,
    /// The user who created the repository.
    pub creator_id: UserId,
    /// The namespace the project lives in.
    pub namespace: ProjectNamespace,
    /// If the project is a fork, details about it.
    pub forked_from_project: Option<BasicProjectDetails>,
    /// The URL to the project avatar.
    pub avatar_url: Option<String>,
    /// The number of stars for the project.
    pub star_count: u64,
    /// The number of forks.
    pub forks_count: u64,
    /// The number of open issues (if issues are enabled).
    pub open_issues_count: Option<u64>,
    /// The continuous integration runner token (if enabled).
    pub runners_token: Option<String>,
    /// Whether builds are publicly visible.
    pub public_builds: bool,
    pub shared_with_groups: Vec<SharedGroup>,
    pub only_allow_merge_if_build_succeeds: bool,
    pub request_access_enabled: bool,

    /// If this is present, it is `ProjectWithAccess`, but since it is so similar, just have it be
    /// optional here.
    pub permissions: Option<Permissions>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
/// Access levels for groups and projects.
pub enum AccessLevel {
    /// Anonymous access.
    Anonymous,
    /// Guest access (can see the project).
    Guest,
    /// Reporter access (can open issues).
    Reporter,
    /// Developer access (can push branches, handle issues and merge requests).
    Developer,
    /// Master access (can push to protected branches).
    Master,
    /// Owner access (full rights).
    Owner,
}

impl From<AccessLevel> for u64 {
    fn from(access: AccessLevel) -> Self {
        match access {
            AccessLevel::Anonymous => 0,
            AccessLevel::Guest => 10,
            AccessLevel::Reporter => 20,
            AccessLevel::Developer => 30,
            AccessLevel::Master => 40,
            AccessLevel::Owner => 50,
        }
    }
}

impl From<u64> for AccessLevel {
    fn from(access: u64) -> Self {
        if access >= 50 {
            AccessLevel::Owner
        } else if access >= 40 {
            AccessLevel::Master
        } else if access >= 30 {
            AccessLevel::Developer
        } else if access >= 20 {
            AccessLevel::Reporter
        } else if access >= 10 {
            AccessLevel::Guest
        } else {
            AccessLevel::Anonymous
        }
    }
}

impl Display for AccessLevel {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(f, "{}", Into::<u64>::into(self.clone()))
    }
}

#[derive(Serialize, Deserialize, Debug)]
/// A member with extra permissions on a project.
pub struct Member {
    /// The username.
    pub username: String,
    /// The display name.
    pub name: String,
    /// The user's ID.
    pub id: UserId,
    /// The state of the user account.
    pub state: UserState,
    /// The URL of the user's avatar.
    pub avatar_url: String,
    /// The URL of the user's profile page.
    pub web_url: String,
    /// The access level of the user.
    pub access_level: u64,
    pub expires_at: Option<DateTime<UTC>>,
}

impl From<Member> for UserBasic {
    fn from(member: Member) -> Self {
        UserBasic {
            username: member.username,
            name: member.name,
            id: member.id,
            state: member.state,
            avatar_url: member.avatar_url,
            web_url: member.web_url,
        }
    }
}

#[derive(Serialize, Deserialize, Debug)]
/// A member with extra permissions on a project.
pub struct AccessRequester {
    /// The username.
    pub username: String,
    /// The display name.
    pub name: String,
    /// The user's ID.
    pub id: UserId,
    /// The state of the user account.
    pub state: UserState,
    /// The URL of the user's avatar.
    pub avatar_url: String,
    /// The URL of the user's profile page.
    pub web_url: String,
    pub requested_at: DateTime<UTC>,
}

impl From<AccessRequester> for UserBasic {
    fn from(member: AccessRequester) -> Self {
        UserBasic {
            username: member.username,
            name: member.name,
            id: member.id,
            state: member.state,
            avatar_url: member.avatar_url,
            web_url: member.web_url,
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
/// Type-safe group ID.
pub struct GroupId(u64);
impl_id!(GroupId);

#[derive(Serialize, Deserialize, Debug)]
/// Group information.
pub struct Group {
    /// The ID of the group.
    pub id: GroupId,
    /// The name of the group.
    pub name: String,
    /// The path to the group.
    pub path: String,
    /// The description of the group.
    pub description: Option<String>,
    /// Integral value for the group's visibility.
    pub visibility_level: u64,
    pub lfs_enabled: bool,
    /// The URL to the group avatar.
    pub avatar_url: String,
    /// The URL to the group's profile page.
    pub web_url: String,
    pub request_access_enabled: bool,
}

#[derive(Serialize, Deserialize, Debug)]
/// Group information with a project listing.
pub struct GroupDetail {
    /// The ID of the group.
    pub id: GroupId,
    /// The name of the group.
    pub name: String,
    /// The path to the group.
    pub path: String,
    /// The description of the group.
    pub description: Option<String>,
    /// Integral value for the group's visibility.
    pub visibility_level: u64,
    pub lfs_enabled: bool,
    /// The URL to the group avatar.
    pub avatar_url: String,
    /// The URL to the group's profile page.
    pub web_url: String,
    /// The projects in a group.
    pub projects: Vec<Project>,
    pub shared_projects: Vec<Project>,
    pub request_access_enabled: bool,
}

impl From<GroupDetail> for Group {
    fn from(detail: GroupDetail) -> Self {
        Group {
            id: detail.id,
            name: detail.name,
            path: detail.path,
            description: detail.description,
            visibility_level: detail.visibility_level,
            lfs_enabled: detail.lfs_enabled,
            avatar_url: detail.avatar_url,
            web_url: detail.web_url,
            request_access_enabled: detail.request_access_enabled,
        }
    }
}

// FIXME: Not actually in entities.rb; it's just a hash dump.
#[derive(Serialize, Deserialize, Debug)]
pub struct Commit {
    pub id: ObjectId,
    pub parent_ids: Vec<ObjectId>,
    pub message: String,
    pub author_name: String,
    pub author_email: String,
    pub authored_date: DateTime<UTC>,
    pub committer_name: String,
    pub committer_email: String,
    pub committed_date: DateTime<UTC>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct RepoBranch {
    pub name: String,
    pub commit: Option<Commit>,
    pub protected: Option<bool>,
    pub developers_can_push: Option<bool>,
    pub developers_can_merge: Option<bool>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct ObjectId(String);

impl ObjectId {
    /// Construct a new `ObjectId`
    pub fn new<O: ToString>(oid: O) -> Self {
        ObjectId(oid.to_string())
    }

    /// The value of the id.
    pub fn value(&self) -> &String {
        &self.0
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ObjectType {
    Tree,
    Blob,
}
enum_serialize!(ObjectType -> "object type",
    Tree => "tree",
    Blob => "blob",
);

#[derive(Serialize, Deserialize, Debug)]
pub struct RepoTreeObject {
    pub id: ObjectId,
    pub name: String,
    #[serde(rename="type")]
    pub type_: ObjectType,
    pub mode: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct RepoCommit {
    pub id: ObjectId,
    pub short_id: ObjectId,
    pub title: String,
    pub author_name: String,
    pub author_email: String,
    pub created_at: DateTime<UTC>,
    pub message: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
pub struct RepoCommitStats {
    pub additions: u64,
    pub deletions: u64,
    pub total: u64,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct RepoCommitDetail {
    pub id: ObjectId,
    pub short_id: ObjectId,
    pub title: String,
    pub author_name: String,
    pub author_email: String,
    pub created_at: DateTime<UTC>,
    pub message: String,
    pub parent_ids: Vec<ObjectId>,
    pub committed_date: DateTime<UTC>,
    pub authored_date: DateTime<UTC>,
    pub stats: RepoCommitStats,
    // This looks to be CI related; ignoring without better docs.
    //pub status: PipelineStatus,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub struct SnippetId(u64);
impl_id!(SnippetId);

#[derive(Serialize, Deserialize, Debug)]
pub struct ProjectSnippet {
    pub id: SnippetId,
    pub title: String,
    pub file_name: String,
    pub author: UserBasic,
    pub updated_at: DateTime<UTC>,
    pub created_at: DateTime<UTC>,
    pub web_url: String,
}

// This is just used as a common "base class" in Ruby.
//#[derive(Serialize, Deserialize, Debug)]
//pub struct ProjectEntity {
//    pub id: ProjectEntityId,
//    pub iid: u64,
//    pub project_id: ProjectId,
//    pub title: String,
//    pub description: String,
//    pub state: ProjectEntityState,
//    pub created_at: DateTime<UTC>,
//    pub updated_at: DateTime<UTC>,
//}

#[derive(Serialize, Deserialize, Debug)]
pub struct RepoDiff {
    pub old_path: String,
    pub new_path: String,
    pub a_mode: String,
    pub b_mode: String,
    pub diff: String,
    pub new_file: bool,
    pub renamed_file: bool,
    pub deleted_file: bool,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub struct MilestoneId(u64);
impl_id!(MilestoneId);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MilestoneState {
    Active,
    Closed,
}
enum_serialize!(MilestoneState -> "milestone type",
    Active => "active",
    Closed => "closed",
);

#[derive(Serialize, Deserialize, Debug)]
pub struct Milestone {
    pub id: MilestoneId,
    pub iid: u64,
    pub project_id: ProjectId,
    pub title: String,
    pub description: String,
    pub state: MilestoneState,
    pub created_at: DateTime<UTC>,
    pub updated_at: DateTime<UTC>,
    pub due_date: Option<NaiveDate>,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub struct IssueId(u64);
impl_id!(IssueId);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum IssueState {
    Opened,
    Closed,
    Reopened,
}
enum_serialize!(IssueState -> "issue type",
    Opened => "opened",
    Closed => "closed",
    Reopened => "reopened",
);

#[derive(Serialize, Deserialize, Debug)]
pub struct Issue {
    pub id: IssueId,
    pub iid: u64,
    pub project_id: ProjectId,
    pub title: String,
    pub description: String,
    pub state: IssueState,
    pub created_at: DateTime<UTC>,
    pub updated_at: DateTime<UTC>,
    pub labels: Vec<String>,
    pub milestone: Option<Milestone>,
    pub assignee: Option<UserBasic>,
    pub subscribed: bool,
    pub user_notes_count: u64,
    pub upvotes: u64,
    pub downvotes: u64,
    pub due_date: Option<NaiveDate>,
    pub confidential: bool,
    pub web_url: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub struct ExternalIssueId(u64);

#[derive(Serialize, Deserialize, Debug)]
pub struct ExternalIssue {
    pub id: ExternalIssueId,
    pub title: String,
}

#[derive(Debug)]
pub enum IssueReference {
    Internal(Issue),
    External(ExternalIssue),
}

impl Serialize for IssueReference {
    fn serialize<S: Serializer>(&self, serializer: &mut S) -> Result<(), S::Error> {
        match *self {
            IssueReference::Internal(ref issue) => issue.serialize(serializer),
            IssueReference::External(ref issue) => issue.serialize(serializer),
        }
    }
}

impl Deserialize for IssueReference {
    fn deserialize<D: Deserializer>(deserializer: &mut D) -> Result<Self, D::Error> {
        let val = try!(Value::deserialize(deserializer));

        serde_json::from_value::<Issue>(val.clone())
            .map(IssueReference::Internal)
            .or_else(|_| serde_json::from_value::<ExternalIssue>(val).map(IssueReference::External))
            .map_err(|err| D::Error::invalid_value(&format!("{:?}", err)))
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub struct MergeRequestId(u64);
impl_id!(MergeRequestId);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MergeStatus {
    Unchecked,
    CanBeMerged,
    CannotBeMerged,
}
enum_serialize!(MergeStatus -> "merge status",
    Unchecked => "unchecked",
    CanBeMerged => "can_be_merged",
    CannotBeMerged => "cannot_be_merged",
);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MergeRequestState {
    Opened,
    Closed,
    Reopened,
    Merged,
    Locked,
}
enum_serialize!(MergeRequestState -> "merge request state",
    Opened => "opened",
    Closed => "closed",
    Reopened => "reopened",
    Merged => "merged",
    Locked => "locked",
);

#[derive(Serialize, Deserialize, Debug)]
pub struct MergeRequest {
    pub id: MergeRequestId,
    pub iid: u64,
    pub project_id: ProjectId,
    pub title: String,
    pub description: Option<String>,
    pub state: MergeRequestState,
    pub created_at: DateTime<UTC>,
    pub updated_at: DateTime<UTC>,
    pub target_branch: String,
    pub source_branch: String,
    pub upvotes: u64,
    pub downvotes: u64,
    pub author: UserBasic,
    pub assignee: Option<UserBasic>,
    pub source_project_id: ProjectId,
    pub target_project_id: ProjectId,
    pub labels: Vec<String>,
    pub work_in_progress: bool,
    pub milestone: Option<Milestone>,
    pub merge_when_build_succeeds: bool,
    pub merge_status: MergeStatus,
    pub sha: ObjectId,
    pub merge_commit_sha: Option<ObjectId>,
    pub subscribed: bool,
    pub user_notes_count: u64,
    pub should_remove_source_branch: bool,
    pub force_remove_source_branch: bool,
    pub web_url: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct MergeRequestChanges {
    pub id: MergeRequestId,
    pub iid: u64,
    pub project_id: ProjectId,
    pub title: String,
    pub description: Option<String>,
    pub state: MergeRequestState,
    pub created_at: DateTime<UTC>,
    pub updated_at: DateTime<UTC>,
    pub target_branch: String,
    pub source_branch: String,
    pub upvotes: u64,
    pub downvotes: u64,
    pub author: UserBasic,
    pub assignee: Option<UserBasic>,
    pub source_project_id: ProjectId,
    pub target_project_id: ProjectId,
    pub labels: Vec<String>,
    pub work_in_progress: bool,
    pub milestone: Option<Milestone>,
    pub merge_when_build_succeeds: bool,
    pub merge_status: MergeStatus,
    pub sha: ObjectId,
    pub merge_commit_sha: Option<ObjectId>,
    pub subscribed: bool,
    pub user_notes_count: u64,
    pub changes: Vec<RepoDiff>,
    pub should_remove_source_branch: bool,
    pub force_remove_source_branch: bool,
    pub web_url: String,
}

impl From<MergeRequestChanges> for MergeRequest {
    fn from(mr: MergeRequestChanges) -> Self {
        MergeRequest {
            id: mr.id,
            iid: mr.iid,
            project_id: mr.project_id,
            title: mr.title,
            description: mr.description,
            state: mr.state,
            created_at: mr.created_at,
            updated_at: mr.updated_at,
            target_branch: mr.target_branch,
            source_branch: mr.source_branch,
            upvotes: mr.upvotes,
            downvotes: mr.downvotes,
            author: mr.author,
            assignee: mr.assignee,
            source_project_id: mr.source_project_id,
            target_project_id: mr.target_project_id,
            labels: mr.labels,
            work_in_progress: mr.work_in_progress,
            milestone: mr.milestone,
            merge_when_build_succeeds: mr.merge_when_build_succeeds,
            merge_status: mr.merge_status,
            sha: mr.sha,
            merge_commit_sha: mr.merge_commit_sha,
            subscribed: mr.subscribed,
            user_notes_count: mr.user_notes_count,
            should_remove_source_branch: mr.should_remove_source_branch,
            force_remove_source_branch: mr.force_remove_source_branch,
            web_url: mr.web_url,
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub struct SshKeyId(u64);
impl_id!(SshKeyId);

#[derive(Serialize, Deserialize, Debug)]
pub struct SshKey {
    pub id: SshKeyId,
    pub title: String,
    pub key: String,
    pub created_at: DateTime<UTC>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct SshKeyWithUser {
    pub id: SshKeyId,
    pub title: String,
    pub key: String,
    pub created_at: DateTime<UTC>,
    pub user: UserFull,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NoteType {
    Commit,
    Issue,
    MergeRequest,
    Snippet,
}
enum_serialize!(NoteType -> "note type",
    Commit => "Commit",
    Issue => "Issue",
    MergeRequest => "MergeRequest",
    Snippet => "Snippet",
);

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum NoteableId {
    Commit(ObjectId),
    Issue(IssueId),
    MergeRequest(MergeRequestId),
    Snippet(SnippetId),
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub struct NoteId(u64);
impl_id!(NoteId);

#[derive(Serialize, Deserialize, Debug)]
pub struct Note {
    pub id: NoteId,
    pub body: String,
    pub attachment: Option<String>,
    pub author: UserBasic,
    pub created_at: DateTime<UTC>,
    pub updated_at: DateTime<UTC>,
    pub system: bool,
    noteable_id: Value, // Keep as JSON because its type depends on what `noteable_type` is.
    pub noteable_type: NoteType,
}

impl Note {
    pub fn noteable_id(&self) -> Option<NoteableId> {
        match self.noteable_type {
            NoteType::Commit => {
                self.noteable_id
                    .as_str()
                    .map(|id| NoteableId::Commit(ObjectId::new(id)))
            },
            NoteType::Issue => {
                self.noteable_id
                    .as_u64()
                    .map(|id| NoteableId::Issue(IssueId::new(id)))
            },
            NoteType::MergeRequest => {
                self.noteable_id
                    .as_u64()
                    .map(|id| NoteableId::MergeRequest(MergeRequestId::new(id)))
            },
            NoteType::Snippet => {
                self.noteable_id
                    .as_u64()
                    .map(|id| NoteableId::Snippet(SnippetId::new(id)))
            },
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
/// Type-safe award ID.
pub struct AwardId(u64);
impl_id!(AwardId);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AwardableId {
    Issue(IssueId),
    MergeRequest(MergeRequestId),
    Snippet(SnippetId),
    Note(NoteId),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AwardableType {
    Issue,
    MergeRequest,
    Snippet,
    Note,
}
enum_serialize!(AwardableType -> "awardable type",
    Issue => "Issue",
    MergeRequest => "MergeRequest",
    Snippet => "Snippet",
    Note => "Note",
);

#[derive(Serialize, Deserialize, Debug)]
pub struct AwardEmoji {
    pub id: AwardId,
    pub name: String,
    pub user: UserBasic,
    pub created_at: DateTime<UTC>,
    pub updated_at: DateTime<UTC>,
    awardable_id: u64,
    pub awardable_type: AwardableType,
}

impl AwardEmoji {
    pub fn awardable_id(&self) -> AwardableId {
        match self.awardable_type {
            AwardableType::Issue => AwardableId::Issue(IssueId::new(self.awardable_id)),
            AwardableType::MergeRequest => {
                AwardableId::MergeRequest(MergeRequestId::new(self.awardable_id))
            },
            AwardableType::Snippet => AwardableId::Snippet(SnippetId::new(self.awardable_id)),
            AwardableType::Note => AwardableId::Note(NoteId::new(self.awardable_id)),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LineType {
    New,
    Old,
}
enum_serialize!(LineType -> "line type",
    New => "new",
    Old => "old",
);

#[derive(Serialize, Deserialize, Debug)]
pub struct CommitNote {
    pub note: String,
    pub path: Option<String>,
    pub line: Option<u64>,
    pub line_type: Option<LineType>,
    pub author: UserBasic,
    pub created_at: DateTime<UTC>,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub struct CommitStatusId(u64);
impl_id!(CommitStatusId);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
/// States for commit statuses.
pub enum StatusState {
    /// The check is queued.
    Pending,
    /// The check is currently running.
    Running,
    /// The check succeeded.
    Success,
    /// The check failed.
    Failed,
    /// The check was canceled.
    Canceled,
}
enum_serialize!(StatusState -> "status state",
    Pending => "pending",
    Running => "running",
    Success => "success",
    Failed => "failed",
    Canceled => "canceled",
);

#[derive(Serialize, Deserialize, Debug)]
pub struct CommitStatus {
    pub id: CommitStatusId,
    pub sha: ObjectId,
    #[serde(rename="ref")]
    pub ref_: Option<String>,
    pub status: StatusState,
    pub name: String,
    pub target_url: Option<String>,
    pub description: Option<String>,
    pub created_at: DateTime<UTC>,
    pub started_at: Option<DateTime<UTC>>,
    pub finished_at: Option<DateTime<UTC>>,
    pub allow_failure: bool,
    pub author: UserBasic,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EventTargetType {
    Commit,
    Issue,
    MergeRequest,
    Snippet,
    ProjectSnippet,
}
enum_serialize!(EventTargetType -> "event target type",
    Commit => "commit",
    Issue => "issue",
    MergeRequest => "merge_request",
    Snippet => "snippet",
    ProjectSnippet => "project_snippet",
);

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum EventTargetId {
    Commit(ObjectId),
    Issue(IssueId),
    MergeRequest(MergeRequestId),
    Snippet(SnippetId),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Event {
    pub title: Option<String>,
    pub project_id: ProjectId,
    pub action_name: String,
    target_id: Value,
    pub target_type: EventTargetType,
    pub author_id: UserId,
    pub data: Option<Value>,
    pub target_title: String,
    pub created_at: DateTime<UTC>,
    pub note: Option<Note>,
    pub author: Option<UserBasic>,
    pub author_username: Option<String>,
}

impl Event {
    pub fn target_id(&self) -> Option<EventTargetId> {
        match self.target_type {
            EventTargetType::Commit => {
                self.target_id
                    .as_str()
                    .map(|id| EventTargetId::Commit(ObjectId(id.to_string())))
            },
            EventTargetType::Issue => {
                self.target_id
                    .as_u64()
                    .map(|id| EventTargetId::Issue(IssueId(id)))
            },
            EventTargetType::MergeRequest => {
                self.target_id
                    .as_u64()
                    .map(|id| EventTargetId::MergeRequest(MergeRequestId(id)))
            },
            EventTargetType::Snippet => {
                self.target_id
                    .as_u64()
                    .map(|id| EventTargetId::Snippet(SnippetId(id)))
            },
            EventTargetType::ProjectSnippet => {
                self.target_id
                    .as_u64()
                    .map(|id| EventTargetId::Snippet(SnippetId(id)))
            },
        }
    }
}

//class ProjectGroupLink < Grape::Entity
//  expose :id, :project_id, :group_id, :group_access
//end

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NamespaceKind {
    User,
    Group,
}
enum_serialize!(NamespaceKind -> "namespace kind",
    User => "user",
    Group => "group",
);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NamespaceId {
    User(UserId),
    Group(GroupId),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Namespace {
    id: u64,
    pub path: String,
    pub kind: NamespaceKind,
}

impl Namespace {
    pub fn id(&self) -> NamespaceId {
        match self.kind {
            NamespaceKind::User => NamespaceId::User(UserId(self.id)),
            NamespaceKind::Group => NamespaceId::Group(GroupId(self.id)),
        }
    }
}

//class ProjectService < Grape::Entity
//  expose :id, :title, :created_at, :updated_at, :active
//  expose :push_events, :issues_events, :merge_requests_events
//  expose :tag_push_events, :note_events, :build_events, :pipeline_events
//  # Expose serialized properties
//  expose :properties do |service, options|
//    field_names = service.fields.
//      select { |field| options[:include_passwords] || field[:type] != 'password' }.
//      map { |field| field[:name] }
//    service.properties.slice(*field_names)
//  end
//end

//class NotificationSetting < Grape::Entity
//  expose :level
//  expose :events, if: ->(notification_setting, _) { notification_setting.custom? } do
//    ::NotificationSetting::EMAIL_EVENTS.each do |event|
//      expose event
//    end
//  end
//end

//class GlobalNotificationSetting < NotificationSetting
//  expose :notification_email do |notification_setting, options|
//    notification_setting.user.notification_email
//  end
//end

//class Label < Grape::Entity
//  expose :name, :color, :description
//  expose :open_issues_count, :closed_issues_count, :open_merge_requests_count

//  expose :subscribed do |label, options|
//    label.subscribed?(options[:current_user])
//  end
//end

//class Compare < Grape::Entity
//  expose :commit, using: Entities::RepoCommit do |compare, options|
//    Commit.decorate(compare.commits, nil).last
//  end

//  expose :commits, using: Entities::RepoCommit do |compare, options|
//    Commit.decorate(compare.commits, nil)
//  end

//  expose :diffs, using: Entities::RepoDiff do |compare, options|
//    compare.diffs(all_diffs: true).to_a
//  end

//  expose :compare_timeout do |compare, options|
//    compare.diffs.overflow?
//  end

//  expose :same, as: :compare_same_ref
//end

//class Contributor < Grape::Entity
//  expose :name, :email, :commits, :additions, :deletions
//end

//class BroadcastMessage < Grape::Entity
//  expose :message, :starts_at, :ends_at, :color, :font
//end

//class ApplicationSetting < Grape::Entity
//  expose :id
//  expose :default_projects_limit
//  expose :signup_enabled
//  expose :signin_enabled
//  expose :gravatar_enabled
//  expose :sign_in_text
//  expose :after_sign_up_text
//  expose :created_at
//  expose :updated_at
//  expose :home_page_url
//  expose :default_branch_protection
//  expose :restricted_visibility_levels
//  expose :max_attachment_size
//  expose :session_expire_delay
//  expose :default_project_visibility
//  expose :default_snippet_visibility
//  expose :default_group_visibility
//  expose :domain_whitelist
//  expose :domain_blacklist_enabled
//  expose :domain_blacklist
//  expose :user_oauth_applications
//  expose :after_sign_out_path
//  expose :container_registry_token_expire_delay
//  expose :repository_storage
//end

//class Release < Grape::Entity
//  expose :tag, as: :tag_name
//  expose :description
//end

//class RepoTag < Grape::Entity
//  expose :name, :message

//  expose :commit do |repo_tag, options|
//    options[:project].repository.commit(repo_tag.target)
//  end

//  expose :release, using: Entities::Release do |repo_tag, options|
//    options[:project].releases.find_by(tag: repo_tag.name)
//  end
//end

//class TriggerRequest < Grape::Entity
//  expose :id, :variables
//end

//class Runner < Grape::Entity
//  expose :id
//  expose :description
//  expose :active
//  expose :is_shared
//  expose :name
//end

//class RunnerDetails < Runner
//  expose :tag_list
//  expose :run_untagged
//  expose :locked
//  expose :version, :revision, :platform, :architecture
//  expose :contacted_at
//  expose :token, if: lambda { |runner, options| options[:current_user].is_admin? || !runner.is_shared? }
//  expose :projects, with: Entities::BasicProjectDetails do |runner, options|
//    if options[:current_user].is_admin?
//      runner.projects
//    else
//      options[:current_user].authorized_projects.where(id: runner.projects)
//    end
//  end
//end

//class BuildArtifactFile < Grape::Entity
//  expose :filename, :size
//end

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
/// Type-safe build ID.
pub struct BuildId(u64);
impl_id!(BuildId);

//class Build < Grape::Entity
//  expose :id, :status, :stage, :name, :ref, :tag, :coverage
//  expose :created_at, :started_at, :finished_at
//  expose :user, with: User
//  expose :artifacts_file, using: BuildArtifactFile, if: -> (build, opts) { build.artifacts? }
//  expose :commit, with: RepoCommit
//  expose :runner, with: Runner
//end

//class Trigger < Grape::Entity
//  expose :token, :created_at, :updated_at, :deleted_at, :last_used
//end

//class Variable < Grape::Entity
//  expose :key, :value
//end

//class EnvironmentBasic < Grape::Entity
//  expose :id, :name, :external_url
//end

//class Environment < EnvironmentBasic
//  expose :project, using: Entities::Project
//end

//class Deployment < Grape::Entity
//  expose :id, :iid, :ref, :sha, :created_at
//  expose :user,        using: Entities::UserBasic
//  expose :environment, using: Entities::EnvironmentBasic
//  expose :deployable,  using: Entities::Build
//end

//class RepoLicense < Grape::Entity
//  expose :key, :name, :nickname
//  expose :featured, as: :popular
//  expose :url, as: :html_url
//  expose(:source_url) { |license| license.meta['source'] }
//  expose(:description) { |license| license.meta['description'] }
//  expose(:conditions) { |license| license.meta['conditions'] }
//  expose(:permissions) { |license| license.meta['permissions'] }
//  expose(:limitations) { |license| license.meta['limitations'] }
//  expose :content
//end

//class TemplatesList < Grape::Entity
//  expose :name
//end

//class Template < Grape::Entity
//  expose :name, :content
//end

//class BroadcastMessage < Grape::Entity
//  expose :id, :message, :starts_at, :ends_at, :color, :font
//  expose :active?, as: :active
//end

//class Todo < Grape::Entity
//  expose :id
//  expose :project, using: Entities::BasicProjectDetails
//  expose :author, using: Entities::UserBasic
//  expose :action_name
//  expose :target_type

//  expose :target do |todo, options|
//    Entities.const_get(todo.target_type).represent(todo.target, options)
//  end

//  expose :target_url do |todo, options|
//    target_type   = todo.target_type.underscore
//    target_url    = "namespace_project_#{target_type}_url"
//    target_anchor = "note_#{todo.note_id}" if todo.note_id?

//    Gitlab::Application.routes.url_helpers.public_send(target_url,
//      todo.project.namespace, todo.project, todo.target, anchor: target_anchor)
//  end

//  expose :body
//  expose :state
//  expose :created_at
//end

//class Pipeline < Grape::Entity
//  expose :id, :status, :ref, :sha, :before_sha, :tag, :yaml_errors

//  expose :user, with: Entities::UserBasic
//  expose :created_at, :updated_at, :started_at, :finished_at, :committed_at
//  expose :duration
//end

//class MergeRequestDiff < Grape::Entity
//  expose :id, :head_commit_sha, :base_commit_sha, :start_commit_sha,
//    :created_at, :merge_request_id, :state, :real_size
//end

//class MergeRequestDiffFull < MergeRequestDiff
//  expose :commits, using: Entities::RepoCommit

//  expose :diffs, using: Entities::RepoDiff do |compare, _|
//    compare.diffs(all_diffs: true).to_a
//  end
//end
